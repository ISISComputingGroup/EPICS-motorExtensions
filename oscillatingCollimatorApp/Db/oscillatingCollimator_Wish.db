# We want to know if we are oscillating but:
# * It doesn't have an encoder we can read
# * If the thread is stopped the mode from the gmc will not change
# * We can't just look at the MOVN of the motor as it does stop occasionally
# 
# So instead, check that (largest motor position in last 10s) != (smallest motor position in last 10s)
record(calcout, "$(P)$(O):MOVING_CALC") {
    field(DESC, "Calculates if moving")
    field(SCAN, ".1 second")
    field(INPA, "$(P)$(O):MOVING:_STABILITY:LOW")
    field(INPB, "$(P)$(O):MOVING:_STABILITY:HIGH")
    field(INPC, "$(P)$(O):MODE:_READ")
    field(CALC, "(B-A)>0.1&&C==2")  # Tolerance of 0.1 degrees, when collimator moves intentionally it is ~2 deg.
    field(OUT, "$(P)$(O):MOVING PP")
    field(FLNK, "$(P)$(O):LAST:POS")
}

record(compress, "$(P)$(O):MOVING:_STABILITY:BUF") {
    field(INP, "$(P)$(O):POS")
    field(ALG, "Circular Buffer")
    field(SCAN, ".1 second")
    field(NSAM, "50")  # 5s at 10Hz = 50 samples
    field(FLNK, "$(P)$(O):MOVING:_STABILITY:LOW")
}

# Smallest motor position value in the last 10 seconds
record(compress, "$(P)$(O):MOVING:_STABILITY:LOW") {
    field(INP, "$(P)$(O):MOVING:_STABILITY:BUF")
    field(ALG, "N to 1 Low Value")
    field(NSAM, "1")
    field(N, "50")  # Should match NSAM in _STABILITY:BUF
    field(FLNK, "$(P)$(O):MOVING:_STABILITY:HIGH")
}

# Largest motor position value in the last 10 seconds
record(compress, "$(P)$(O):MOVING:_STABILITY:HIGH") {
    field(INP, "$(P)$(O):MOVING:_STABILITY:BUF")
    field(ALG, "N to 1 High Value")
    field(NSAM, "1")
    field(N, "50")  # Should match NSAM in _STABILITY:BUF
}

record(bi, "$(P)$(O):MOVING") {
    field(DESC, "Is the collimator moving")
    field(ZNAM, "Not Moving")
    field(ONAM, "Moving")
    info(INTEREST, "MEDIUM")
}

record(bo, "$(P)$(O):USES_LSR")
{
	field(DESC, "Whether the inst. uses the laser")
	field(VAL, "0")
}



record(ao, "$(P)$(O):FULLREV:SP") {
    field(DTYP, "$(OTYP)")
    field(EGU, "stp")
    field(PREC, "2")
    field(OUT, "@asyn(Galil,0)USER_VAR fullrev")
    field(FLNK, "$(P)$(O):FULLREV")
}

record(ai, "$(P)$(O):FULLREV") {
    field(SCAN, "1 second")
    field(DTYP, "$(OTYP)")
    field(EGU, "stp")
    field(PREC, "2")
    field(INP, "@asyn(Galil,0)USER_VAR fullrev")
    field(PREC, "2")
}

record(ao,"$(P)$(O):MNTCYCLES:SP") {
    field(DESC, "Num cycles between maint rot")
    field(DTYP, "$(OTYP)")
    field(EGU, "")
    field(PREC, "2")
    field(OUT, "@asyn(Galil,0)USER_VAR cycles")
    field(VAL, "5000")
    field(PINI, "YES")
    info(archive, "VAL")
    info(autosaveFields, "VAL")
}

record(ai,"$(P)$(O):MNTCYCLES") {
    field(DESC, "Num cycles between maint rot")
    field(SCAN, "1 second")
    field(DTYP, "$(OTYP)")
    field(INP, "@asyn(Galil,0)USER_VAR cycles")
    field(EGU, "")
    field(PREC, "2")
    info(INTEREST, "HIGH")
    info(archive, "VAL")
}

record(calc, "$(P)$(O):MNTTIME") {
    field(DESC, "Time to maintenance rotation")
    field(INPA, "$(P)$(O):FREQ:SP CP")
    field(INPB, "$(P)$(O):MNTCYCLES CP")
    field(INPC, "$(P)$(O):CYCLE CP")
    field(CALC, "((1/A)*B)-((1/A)*C)")
    field(EGU, "sec")
}

alias("$(P)$(O):ANGLE:SP", "$(P)$(O):ANGLE")

# Swept angle calcs

record(calcout, "$(P)$(O):STEPS_PER_REV") {
    field(DESC, "Motor steps per revolution")
    field(INPA, "$(STEPS_PER_REV)")
    field(INPB, "$(MICROSTEPS_PER_STEP)")
    field(INPC, "$(GEARBOX_RATIO)")
    field(CALC, "A*B*C")
    field(EGU, "stp")
    field(OUT, "$(P)$(O):FULLREV:SP PP")
    field(FLNK, "$(P)$(O):STEPS_PER_DEG")
}

record(calc, "$(P)$(O):STEPS_PER_DEG") {
    field(DESC, "Motor steps per degree")
    field(INPA, "$(P)$(O):STEPS_PER_REV")
    field(CALC, "A/360")
    field(EGU, "stp/deg")
	field(FLNK, "$(P)$(O):CIRCUMFERENCE")
}

record(calc, "$(P)$(O):CIRCUMFERENCE") {
    field(DESC, "Circumfer of collimator")
    field(EGU, "mm")
    field(PREC, "3")
    field(INPA, "$(P)$(O):RADIUS")
    field(CALC, "2*PI*A")
	field(FLNK, "$(P)$(O):STEPS")
}

record(calc, "$(P)$(O):STEPS") {
    field(DESC, "Motor steps per mm")
    field(INPA, "$(P)$(O):CIRCUMFERENCE")
    field(INPB, "$(P)$(O):STEPS_PER_REV")
    field(CALC, "B/A")
    field(EGU, "stp/mm")
	field(FLNK, "$(P)$(O):MM_PER_DEG")
}

record(calc, "$(P)$(O):MM_PER_DEG") {
    field(INPA, "$(P)$(O):CIRCUMFERENCE")
    field(CALC, "A/360")
    field(EGU, "mm/deg")
    field(DESC, "mm per degree")
	field(FLNK, "$(P)$(O):SWEPT_DIST_MM")
}

record(calc, "$(P)$(O):SWEPT_DIST_MM") {
    field(DESC, "Actual swept distance (mm)")
    field(INPA, "$(P)$(O):ANGLE:SP")
    field(INPB, "$(P)$(O):MM_PER_DEG")
    field(CALC, "A*B")
    field(EGU, "mm")
    field(FLNK, "$(P)$(O):ENC_COUNTS_PER_DEG")
}


record(calc, "$(P)$(O):ENC_COUNTS_PER_DEG") {
    field(DESC, "Encoder counts per degree")
    field(INPA, "$(ENC_COUNTS_PER_MM)")
    field(INPB, "$(P)$(O):MM_PER_DEG")
    field(CALC, "A*B")
    field(EGU, "")
	field(FLNK, "$(P)$(O):DIST:PART:SP")
}

record(calc, "$(P)$(O):DIST:PART:SP") {
    field(DESC, "Swept distance, setpoint")
    field(INPA, "$(P)$(O):STEPS")
    field(INPB, "$(P)$(O):SWEPT_DIST_MM")
    field(CALC, "A*B")
    field(EGU, "stp")
    field(PREC, "0")
    field(FLNK, "$(P)$(O):VEL:SP:DISC")
}


# Operating Frequency - no readback from galil code so just use the set frequency 

alias("$(P)$(O):FREQ:SP:RBV", "$(P)$(O):FREQ")


# Motor position

record(calc, "$(P)$(O):POS:_CALC") {
    field(SCAN, ".1 second")
    field(INPA, "$(P)$(M).RBV MS")
    field(CALC, "(A<0)?A+360:A")
}

record(ai, "$(P)$(O):POS") {
    field(INP, "$(P)$(O):POS:_CALC CP MS")
    field(DESC, "Current motor position")
    field(PREC, "2")
    field(EGU, "deg")
    info(INTEREST, "MEDIUM")
}

